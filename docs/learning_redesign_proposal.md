# 🎓 학습 시스템 재설계: 검색 자체를 학습하는 방향

## 🔴 **현재 시스템의 근본적 문제**

### **현재 방식: "결과 학습"**
```
사용자 입력: "ch 샤르도네"
  ↓
시스템이 100개 후보 제시
  ↓
사용자가 "3A24401 찾스하이직 샤르도네" 선택
  ↓
학습 저장: "ch 샤르도네" → "3A24401"
  ↓
다음에 또 "ch 샤르도네" 입력하면?
  → 여전히 100개 후보 제시
  → 단지 "3A24401"의 점수만 높아짐
```

**문제점**:
- ❌ 검색 과정은 전혀 개선되지 않음
- ❌ 여전히 무관한 후보 100개를 계산해야 함
- ❌ "ch"가 무엇인지 시스템이 이해하지 못함
- ❌ 학습이 쌓여도 검색 자체는 똑같음

---

## 💡 **새로운 방향: "검색 자체를 학습"**

### **목표**
```
사용자가 "ch" 입력 → 시스템이 "찰스하이직"을 찾는 방법을 학습
사용자가 "bl" 입력 → 시스템이 "로쉬벨렌"을 찾는 방법을 학습
사용자가 "lc" 입력 → 시스템이 "레이크 찰리스"를 찾는 방법을 학습
```

**핵심**: 학습이 누적될수록 **검색 키워드 자체가 정확**해져야 함!

---

## 🧠 **개선 아이디어**

### **아이디어 1: 토큰 매핑 학습 (Token Mapping)**

#### **개념**
사용자의 입력 토큰 → 실제 검색해야 할 키워드 매핑을 학습

#### **예시**
```
학습 데이터:
- "ch" → "찰스하이직"
- "bl" → "로쉬벨렌"
- "lc" → "레이크 찰리스"
- "샤도" → "샤르도네"
- "까베" → "카베르네소비뇽"

검색 과정:
입력: "ch 샤도 24병"
  ↓
토큰 분해: ["ch", "샤도", "24병"]
  ↓
토큰 변환:
  - "ch" → "찰스하이직" (학습됨)
  - "샤도" → "샤르도네" (학습됨)
  - "24병" → 제거
  ↓
확장된 검색어: "찰스하이직 샤르도네"
  ↓
검색: 훨씬 정확한 후보 발견!
```

#### **저장 구조**
```sql
CREATE TABLE token_mapping (
  token TEXT PRIMARY KEY,           -- "ch", "bl", "샤도"
  mapped_text TEXT NOT NULL,        -- "찰스하이직", "로쉬벨렌", "샤르도네"
  mapping_type TEXT DEFAULT 'producer',  -- producer, varietal, region
  confidence REAL DEFAULT 1.0,      -- 신뢰도 (학습 횟수 기반)
  learned_count INTEGER DEFAULT 1,  -- 학습 횟수
  last_used_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

---

### **아이디어 2: 컨텍스트 기반 학습 (Context Learning)**

#### **개념**
단순 1:1 매핑이 아니라, 문맥을 이해하는 학습

#### **예시**
```
학습 데이터:
- "ch" + "샤르도네" → "찾스하이직" 브랜드
- "ch" + "피노누아" → "찰스하이직" 브랜드 (다른 발음?)
- "ch" + "까베" → "샤또" 브랜드 (전혀 다른 브랜드!)

컨텍스트 학습:
입력: "ch 샤르도네"
  → 이전에 "ch + 샤르도네"를 선택한 패턴 확인
  → "찰스하이직 샤르도네"를 최우선 검색

입력: "ch 까베"
  → 이전에 "ch + 까베"를 선택한 패턴 확인
  → "샤또 카베르네소비뇽"을 최우선 검색
```

#### **저장 구조**
```sql
CREATE TABLE context_mapping (
  token1 TEXT NOT NULL,             -- "ch"
  token2 TEXT NOT NULL,             -- "샤르도네"
  target_producer TEXT,             -- "찰스하이직"
  target_varietal TEXT,             -- "샤르도네"
  item_no TEXT,                     -- "3A24401"
  learned_count INTEGER DEFAULT 1,
  confidence REAL DEFAULT 1.0,
  PRIMARY KEY (token1, token2)
);
```

---

### **아이디어 3: 역색인 기반 학습 (Inverted Index Learning)**

#### **개념**
품목명을 토큰 단위로 분해하여 역색인 구축 + 학습으로 가중치 조정

#### **예시**
```
초기 색인 (자동 구축):
Token: "찰스"
  → 3A24401: 찰스하이직 샤르도네 (weight: 1.0)
  → 3A24402: 찰스하이직 피노누아 (weight: 1.0)

Token: "샤르도네"
  → 3A24401: 찰스하이직 샤르도네 (weight: 1.0)
  → 3B12345: 샤또 샤르도네 (weight: 1.0)
  → 3C67890: 로제 샤르도네 (weight: 1.0)

학습 후:
사용자가 "ch 샤르도네" 입력 → "3A24401" 선택 (5회)

Token: "ch"
  → 3A24401: 찰스하이직 샤르도네 (weight: 5.0) ← 학습!
  → 3C67890: 샤또... (weight: 0.1)

검색:
입력: "ch 샤르도네"
  ↓
Token 분해: ["ch", "샤르도네"]
  ↓
역색인 조회:
  - "ch" → 3A24401 (5.0), 3C67890 (0.1)
  - "샤르도네" → 3A24401 (1.0), 3B12345 (1.0), 3C67890 (1.0)
  ↓
종합 점수:
  - 3A24401: 5.0 + 1.0 = 6.0 ← 압도적 1위!
  - 3B12345: 0.0 + 1.0 = 1.0
  - 3C67890: 0.1 + 1.0 = 1.1
```

#### **저장 구조**
```sql
CREATE TABLE inverted_index (
  token TEXT NOT NULL,              -- "ch", "찰스", "샤르도네"
  item_no TEXT NOT NULL,            -- "3A24401"
  weight REAL DEFAULT 1.0,          -- 학습 가중치
  learned_count INTEGER DEFAULT 0,  -- 사용자가 선택한 횟수
  auto_generated INTEGER DEFAULT 1, -- 자동 생성 여부
  PRIMARY KEY (token, item_no)
);

-- 학습 시 업데이트
UPDATE inverted_index 
SET weight = weight + 1.0, 
    learned_count = learned_count + 1,
    auto_generated = 0
WHERE token = 'ch' AND item_no = '3A24401';
```

---

### **아이디어 4: 패턴 기반 학습 (Pattern Learning)**

#### **개념**
사용자의 입력 패턴 자체를 학습

#### **예시**
```
학습된 패턴:
1. "[약어2자] [품종]" → 생산자 약어 + 품종
   예: "ch 샤르도네", "bl 피노누아", "lc 말보로"

2. "[한글3자이상] [품종]" → 생산자명 + 품종
   예: "찰스하이직 샤르도네", "로쉬벨렌 피노누아"

3. "[영문] [숫자]" → 영문명 + 빈티지
   예: "caymus 2021", "opus 2020"

패턴 적용:
입력: "ch 샤르도네"
  ↓
패턴 매칭: "[약어2자] [품종]" 패턴 감지
  ↓
검색 전략:
  1. 약어 "ch"를 생산자 약어로 해석
  2. "샤르도네"를 품종으로 해석
  3. 생산자 약어 매핑 테이블 조회: "ch" → "찰스하이직"
  4. 최종 검색: "찰스하이직" + "샤르도네"
```

---

## 🎯 **통합 제안: 3단계 학습 시스템**

### **Phase 1: 토큰 매핑 학습 (간단, 효과적)**
```
학습 방식: 
- 사용자가 후보 선택 시 입력 토큰 자동 추출
- 선택된 품목명에서 핵심 키워드 추출
- 토큰 → 키워드 매핑 저장

예시:
입력: "ch 샤르도네" → 선택: "찰스하이직 샤르도네 2022"
학습:
  - "ch" → "찰스하이직" (생산자 매핑)
  - "샤르도네" → "샤르도네" (품종 확인)

다음 검색:
입력: "ch 피노" → 확장: "찰스하이직 피노" → 정확한 검색!
```

### **Phase 2: 역색인 + 가중치 학습**
```
초기: 모든 품목을 토큰 단위로 색인 구축
학습: 사용자 선택 시 해당 토큰-품목 가중치 증가
검색: 토큰별 가중치 합산으로 후보 순위 결정
```

### **Phase 3: 컨텍스트 + 패턴 학습**
```
문맥 이해: "ch 샤르도네"와 "ch 까베"는 다른 결과
패턴 인식: 입력 형태로 검색 전략 자동 선택
```

---

## ✅ **핵심 차이점**

### **기존 방식**
```
학습: "ch 샤르도네" → "3A24401" (품목번호만 저장)
검색: "ch 샤르도네" → 여전히 100개 후보 → 3A24401 점수만 높음
```

### **새로운 방식**
```
학습: "ch" → "찰스하이직" (토큰 매핑 이해)
검색: "ch 샤르도네" → "찰스하이직 샤르도네" 직접 검색 → 후보 10개 이하!
```

---

## 🤔 **논의 필요 사항**

1. **어느 방향이 좋을까요?**
   - 토큰 매핑 (간단, 빠른 효과)
   - 역색인 학습 (강력, 복잡)
   - 패턴 학습 (지능적, 구현 어려움)
   - 아니면 다른 아이디어?

2. **기존 학습 데이터는?**
   - 기존 item_alias 데이터를 변환할까?
   - 아니면 새로 시작할까?

3. **자동화 수준은?**
   - 완전 자동 학습 (사용자 선택만으로)
   - 반자동 (사용자가 매핑 확인/수정)
   - 수동 (명시적 학습 버튼)

4. **학습 범위는?**
   - 생산자 약어만? (ch, bl, lc)
   - 품종 약어도? (샤도, 까베, 피노)
   - 모든 토큰?

---

**어떤 방향으로 나아가면 좋을까요?** 🤔
